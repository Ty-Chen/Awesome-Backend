网络通信面试攻略
====

网络架构相关
-----

* #### 在子网210.27.48.21/30种有多少个可用地址？分别是什么？
  答：简: 30表示的是网络号(network number)是30位，剩下2位中11是广播(broadcast)地址，00是multicast地址，只有01和10可以作为host address。
详: 210.27.48.21/30代表的子网的网络号是30位，即网络号是210.27.48.21 & 255.255.255.251=210.27.48.20，此子网的地址空间是2位，即可以有4个地址：210.27.48.20, 210.27.48.21, 210.27.48.22, 210.27.48.23。第一个地址的主机号(host number/id)是0，而主机号0代表的是multicast地址。最后一个地址的最后两位是11，主机号每一位都为1代表的是广播(broadcast)地址。所以只有中间两个地址可以给host使用。其实那个问题本身不准确，广播或multicast地止也是可以使用的地址，所以回答4也应该正确，当然问的人也可能是想要你回答2。我个人觉得最好的回答是一个广播地址，一个multicast地址，2个unicast地址。

-----

* #### 路由表示做什么用的？在linux环境中怎么来配置一条默认路由？
  答：路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。在Linux上可以用“route add default gw <默认路由器IP>”来配置一条默认路由。
详: 路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。路由表的每一行至少有目标网络号、netmask、到这个子网应该使用的网卡。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的netmask和包里的目标IP地址做并逻辑运算(&)找出目标网络号，如果此网络号和这一行里的网络号相同就将这条路由保留下来做为备用路由，如果已经有备用路由了就在这两条路由里将网络号最长的留下来，另一条丢掉，如此接着扫描下一行直到结束。如果扫描结束任没有找到任何路由，就用默认路由。确定路由后，直接将包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。题外话：路由算法其实效率很差，而且不scalable，解决办法是使用IP交换机，比如MPLS。
在Linux上可以用“route add default gw <默认路由器IP>”来配置一条默认路由。


-----

* #### 在网络中有两台主机A和B，并通过路由器和其他交换设备连接起来，已经确认物理连接正确无误，怎么来测试这两台机器是否连通？如果不通，怎么来判断故障点？怎么排除故障？
  答：测试这两台机器是否连通：从一台机器ping另一台机器，如果ping不通，用traceroute可以确定是哪个路由器不能连通，然后再找问题是在交换设备/hup/cable等。

-----

* #### 网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？
  答：答案一:
1）进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2）线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
答案二:
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：
1）速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。
2）资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。
3）同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。


-----

* #### 路由表的网段怎么存储、查找   
  答：存储：
根据RIP协议报文（包含目的网络，距离以及下一跳），若目的网络在原路由表中不存在，则直接加入路由表中；若存在，且距离比原路由表比较小，则更新距离，否则忽略。

  查找：
  路由表中有目的地址网络，子网掩码，下一跳这些数据；
  先从数据包中获取目的地址，让该地址与路由表中的子网掩码逐个进行与操作，若结果和子网掩码对应的目的地址相匹配，则从下一跳指向的端口进行转发，否则查找下一个路由表项；

-----

* #### dns怎么解析的？
    答：主机通过ISP接入了互联网，那么ISP就会分配一个DNS服务器；
  主机向ISP DNS发起查询www.baidu.com请求；
  ISP DNS收拿到请求后，先检查一下自己的缓存中有没有这个地址，有的话就直接返回,如果缓存中没有的话，ISP DNS会从配置文件里面读取13个根域名服务器的地址。并向其中一台发起请求。
  根服务器拿到这个请求后，知道他是com.这个顶级域名下的，所以就会返回com域中的NS记录;
  ISP DNS向其中一台再次发起请求，com域的服务器发现你这请求是baidu.com这个域的，一查发现了这个域的NS，那我就返回给你，你再去查;
  ISP DNS不厌其烦的再次向baidu.com这个域的权威服务器发起请求，baidu.com收到之后，查了下有www的这台主机，就把这个IP返回给你了;
  然后ISPDNS拿到了之后，将其返回给了客户端，并且把这个保存在高速缓存中。

-----

* #### ipv4与ipv6
    答：一、IPv6具有更大的地址空间。IPv4中规定IP地址长度为32，最大地址个数为232；而IPv6中IP地址的长度为128，即最大地址个数为2128。与32位地址空间相比，其地址空间增加了2128-232个。

  二、IPv6使用更小的路由表。IPv6的地址分配一开始就遵循聚类（Aggregation）的原则，这使得路由器能在路由表中用一条记录（Entry）表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。

  三、IPv6增加了增强的组播（Multicast）支持以及对流的控制（Flow Control），这使得网络上的多媒体应用有了长足发展的机会，为服务质量（QoS，Quality of Service）控制提供了良好的网络平台。

  四、IPv6加入了对自动配置（Auto Configuration）的支持。这是对DHCP协议的改进和扩展，使得网络（尤其是局域网）的管理更加方便和快捷。

  五、IPv6具有更高的安全性。在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验，在IPV6中的加密与鉴别选项提供了分组的保密性与完整性。极大的增强了网络的安全性。

  六、允许扩充。如果新的技术或应用需要时，IPV6允许协议进行扩充。

  七、更好的头部格式。IPV6使用新的头部格式，其选项与基本头部分开，如果需要，可将选项插入到基本头部与上层数据之间。这就简化和加速了路由选择过程，因为大多数的选项不需要由路由选择。

  八、新的选项。IPV6有一些新的选项来实现附加的功能。

-----

* ####
  答：

TCP/IP知识
-----


* #### tcp和udp的区别
  答：TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。  
  &emsp;&emsp;UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快

-----

* #### 流量控制和拥塞控制
  答：拥塞控制 --- 网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。  
  &emsp;&emsp;流量控制 --- 数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。

-----

* #### tcp连接建立的时候3次握手，断开连接的4次握手的具体过程
  答：TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。

  三次握手协议指的是在发送数据的准备阶段，服务器端和客户端之间需要进行三次交互：

  第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

  第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

  连接建立后，客户端和服务器就可以开始进行数据传输了。

  为什么客户端需要再发送一次确认？

  client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

  四次挥手：

    （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

  （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

  （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

  （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

  为什么TCP连接是三次，挥手确是四次？

  在TCP连接中，服务器端的SYN和ACK向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的ACK和FIN是是分两次发送的。因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了。

  为什么在第四次挥手后会有2个MSL的延时？

  MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。
  假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。


-----


* #### epoll与select的区别
  答：1）select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048，一般来说内存越大，fd上限越大，1G内存都能达到大约10w左右。
2）select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，而不需要不断的去轮询查找就绪的描述符，这就是epoll高效最本质的原因。
3）无论是select还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝

-----


* #### epoll中et和lt的区别与实现原理
  答：LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。
ET：边缘触发，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。

-----

* #### connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？
  答：最通常的方法最有效的是加定时器；也可以采用非阻塞模式。
或者考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂停运行；异步传输机制则不然，会立即返回。

-----

* #### 网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？
  答：若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。
-----

* #### TTL是什么？有什么用处，通常那些工具会用到它？（ping? traceroute? ifconfig? netstat?）
  答：TTL是Time To Live，一般是hup count，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。
详: TTL是Time To Live，目前是hup count，当包每经过一个路由器它就会被减去一，如果它变成0，路由器就会把包丢掉。IP网络往往带有环(loop)，比如子网A和子网B有两个路由器相连，它就是一个loop。TTL的主要目的是防止包在有回路的网络上死转，因为包的TTL最终后变成0而使得此包从网上消失(此时往往路由器会送一个ICMP包回来，traceroute就是根据这个做的)。ping会送包出去，所以里面有它，但是ping不一定非要不可它。traceroute则是完全因为有它才能成的。ifconfig是用来配置网卡的，netstat -rn 是用来列路由表的，所以都用不着它

-----

* #### 网络编程的一般步骤
  答：对于TCP连接：
1.服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字。
2.客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。
TCP总结：
Server端： socket -- bind -- listen--  accept--  recv/send-- close
Client端：socket------- conncet------send/recv------close.

对于UDP连接：
1.服务器端:1）创建套接字create；2）绑定端口号bind；3）接收/发送消息recvfrom/sendto；4）关闭套接字。
2.客户端:1）创建套接字create；2）发送/接收消息sendto/recvfrom；3）关闭套接字.
UDP总结:
Server端：socket ----bind ----recvfrom/sendto----close
Client端：socket ----  sendto/recvfrom----close.

-----

* #### TCP的重发机制是怎么实现的？
  答：1）滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。
2）选择重传，用于对传输出错的序列进行重传。

-----

* #### TCP为什么不是两次连接？而是三次握手？
  答：如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。
-----

* #### socket编程，如果client断电了，服务器如何快速知道？
  答：使用定时器（适合有数据流动的情况）； 使用socket选项SO_KEEPALIVE（适合没有数据流动的情况）
-----

* #### tcp三次握手的过程，accept发生在三次握手哪个阶段？
  答：client 的 connect  引起3次握手
server 在socket， bind， listen后，阻塞在accept，三次握手完成后，accept返回一个fd，因此accept发生在三次握手之后。

-----

* #### Tcp流， udp的数据报，之间有什么区别，为什么TCP要叫做数据流？
  答：TCP本身是面向连接的协议，S和C之间要使用TCP，必须先建立连接，数据就在该连接上流动，可以是双向的，没有边界。所以叫数据流 ，占系统资源多
UDP不是面向连接的，不存在建立连接，释放连接，每个数据包都是独立的包，有边界，一般不会合并。
TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证

-----

* #### socket在什么情况下可读?
  答：1. 接收缓冲区有数据，一定可读
  2. 对方正常关闭socket，也是可读
  3. 对于侦听socket，有新连接到达也可读
  4. socket有错误发生，且pending

-----


* #### 流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？
  答：拥塞控制是把整体看成一个处理对象的，流量控制是对单个的节点。
感知的手段应该不少，比如在TCP协议里，TCP报文的重传本身就可以作为拥塞的依据。依据这样的原理， 应该可以设计出很多手段。


-----

* #### TCP通讯中，select到读事件，但是读到的数据量是0，为什么，如何解决?
  答：select 返回0代表超时。select出错返回-1。
select到读事件，但是读到的数据量为0，说明对方已经关闭了socket的读端。本端关闭读即可。
当select出错时，会将接口置为可读又可写。这时就要通过判断select的返回值为-1来区分。


-----

* #### timewait如何强制结束
  答：

-----

* #### receive返回值为0表示什么
  答：

-----

* #### 用UDP协议通讯时怎样得知目标机是否获得了数据包？
  答：在UDP之上自定义一个通讯协议：每个数据包中包含一个唯一标识，可以用编号也可以用时间；接收端收到数据包后回发一个数据包，包含收到的这个唯一标识；发送端在预定时间内没有收到回执则自动重发，重发一定次数后仍未收到回执则认为发送失败。

-----

* #### 什么是滑动窗口？
  答：  滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包(称窗口尺寸)。

      TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

      滑动窗口机制为端到端设备间的数据传输提供了可靠的流量控制机制。然而，它只能在源端设备和目的端设备起作用，当网络中间设备(例如路由器等)发生拥塞时，滑动窗口机制将不起作用。

-----

* #### TCP的connect函数与UDP的connect函数区别？
  答： 在网络编程中，connect函数通常用于客户端建立tcp连接。tcp连接的建立实际上就是三次“握手”的过程。

    udp协议提供的是面向非连接的服务，通信双方不需要建立连接。一方只需要建立好套接字，并显式或由系统绑定地址和端口号后就可以发送/接收数据包。和tcp不同的是，使用udp协议的数据报套接字(SOCK_DGRAM)并不限定唯一的通信方。既可以发送（sendto）数据给任意的接受方，也可以从任意的发送方接收（recvfrom）数据。

     如果希望为一个数据报套接字指定唯一的通信方时，可以使用connect来实现这一功能。需要注意的是，在数据报套接字上使用connect并不是建立连接，不存在“握手”的过程。仅仅是为这个套接字指定一个通信方，一旦指定了对方的地址，就可以通过send/recv来发送/接收数据了。而且可以在这个数据报套接字上多次调用connect函数来指定不同的通信方。
  在udp中使用connect的方法和tcp中类似，只需在创建套接字时，把套接字的类型由SOCK_STREAM换成SOCK_DGRAM即可。

-----

* #### socket什么情况下可读？
  答：套接字准备好读的条件:

  a）该套接字接受缓冲区中的数据字节数大于等于套接字接受缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值(也就是返回准备好读入的数据)。我们可以使用SO_RCVLOWAT套接字选项设置该套接字的低水位标记。对于tcp和udp套接字而言，其默认值为1。

  b）该套接字的读半部关闭（也就是接受了FIN的tcp连接）。对这样的套接字的读操作将不阻塞并返回0.（也就是返回EOF）

  c）该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不阻塞。

  d）其上有一个套接字错误待处理。对这样的套接字的读操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这样待处理错误(pending error)也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。

  套接字准备好写的条件:

  a）该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已连接，或者该套接字不需要连接（如udp套接字）。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值（例如由传输层接受的字节数）。我们可以使用SO_SNDLOWAT套接字选项来设置该套接字的低水位标记。对于tcp和udp而言，其默认值通常为2048。

  b）该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIPE信号。

  c） 使用非阻塞connect的套接字已建立连接，或者connect已经以失败告终。

  d） 其上有一个套接字错误待处理。对这样的套接字的写操作将不阻塞并返回-1（也就是返回一个错误），同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。

-----

* #### TCP的数据编号与确认
  答：TCP将所要传送的整个报文(这可能包括许多个报文段)看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。TCP的确认是对接收到的数据的最高序号(即收到的数据流中的最后一个序号)表示确认。但接收端返回的确认序号是已收到的数据的最高序号加1。也就是说，确认序号表示接收端期望下次收到的数据中的第一个数据字节的序号。

-----

* #### 在发送端，TCP是怎样决定发送个报文段的时机呢
  答：  TCP有三种基本机制来控制报文段的发送。
  第一种机制是TCP维持一个变量，它等于最大报文段长度MSS，只要发送缓存从发送进程得到的数据达到MSS字节时，就组装成—个TCP报文段，然后发送出去。
  第二种机制是发送端的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。
  第三种机制是发送端的一个计时器时间到了，这时就把当前已有的缓存数据装入报文段发送出去。

-----

* #### TCP流量控制：
  答：   接受方告诉发送方自己的接受窗口大小，发送方调整自己的发送窗口大小。窗口以字节为单位。
  在TCP的实现中广泛使用Nagle算法：Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。若发送端应用进程将欲发送的数据逐个字节地达到发送端的TCP缓存，则发送端就将第一个字符(—个字符的长度是一个字节)发送出去，将后面到达的字符将都缓存起来。当接收端收到对第一个字符的确认后，再将缓存中的所有字符装成一个报文段发送出去，同时继续对随后到达的字符进行缓存。只有在收到对前一个报文段的确认时才继续发送下一个报文段。当字符到达较快而网络速率较慢时，用这样的方法可明显的减少所用的网络带宽，算法还规定，当到达的字符已达到窗口大小的一半或己达到报文段的最大长度时，就立即发送一个报文段。


-----

* #### Nagle算法的规则：
  答：（1）如果包长度达到MSS，则允许发送；
（2）如果该包含有FIN，则允许发送；
（3）设置了TCP_NODELAY选项，则允许发送；
（4）未设置TCP_CORK选项时，若所有发出的小数据包（长度小于MSS）均被确认，则允许发送；
（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。


-----

* #### 糊涂窗口综合症(silly window syndrome)
  答：  有时也会使TCP的性能变坏。
  设想这种情况：接收端的缓存已满，而交互的应用进程一次只从缓存中读取一个字符(这样就在缓存产生1个字节的空位，然后向发送端发送确认，并将窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送端又传来1个字符(但发来的IP数据报是41字节长。接收端发回确认，仍然将窗口设置为一个字节。这样进行下去，网络的效率将会很低。
  要解决这个问题，可让接收端等待一段时间，使得或者缓存已能有足够的空间容纳—个最长的报文段，或者缓存已有一半的中间处于空的状态。只要出现这两种情况之一，就发出确认报文，并向发送端通知当前的窗口大小。此外，发送端也不要发送太小的报文段，而是将数掘积累成足够大的报文段，或达到接收端缓存的空间的—半大小。
  上述两种方法（nagle和糊涂窗口）可配合使用。使得在发送端不发送很小的报文段的同时，接收端也不要在缓存刚刚有了一点小的空位置就急忙将一个很小的窗口大小通知给发送端。


-----

* #### 拥塞控制
  答：  若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况叫做拥塞。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性过程，设计所有主机，所有的路由器。而流量控制是个端到端的问题。
  四种拥塞控制的算法：慢开始、拥塞避免、快重传、快恢复
  慢开始和拥塞避免（以下cwnd的大小单位都是报文段）
  发送方维持一个拥塞窗口cwnd, 发送方让发送窗口 等于 拥塞窗口和 接收方 接收窗口的最小值。
  发送方控制拥塞窗口的原则是：只要没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
  慢开始 : 开始发送数据时，先探测一下，有小到大逐渐增大发送窗口。cwnd = 1, 然后每经过一个传输轮次就翻倍
  拥塞避免 : 让cwnd缓慢增大, 每经过一个传输轮次就+1
  慢开始门限ssthresh : 只要发送方判断网络出现拥塞（根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一般，然后把cwnd重新设定为1
  cwnd < ssthresh, 使用慢开始算法
  cwnd > ssthresh, 使用拥塞避免算法
  cwnd = ssthresh, 随意
  快重传和快恢复
  快重传 : 接收方及时发送确认, 而发送方只要一连收到三个重复确认, 马上重传而不等待重传计时器。（需要明确的是确认指的是确认收到的有序的最大分节序号）由于尽早重传未被确认的报文段，整的网络的吞吐量提高20%
  快恢复 : 当发送方一连收到三个重复确认时, ssthresh减半, cwnd设为ssthresh，然后执行拥塞避免算法。

-----

* #### 为什么要三次握手, 两次不可以吗?
  答：   试想一下, A第一次发送请求连接, 但是在网络某节点滞留了, A超时重传, 然后这一次一切正常, A跟B就愉快地进行数据传输了. 等到连接释放了以后, 那个迷失了的连接请求突然到了B那, 如果是两次握手的话, B发送确认, 它们就算是建立起了连接了. 事实上A并不会理会这个确认, 因为我压根没有要传数据啊. 但是B却傻傻地以为有数据要来, 苦苦等待. 结果就是造成资源的浪费.
  更加接地气的解释就是 : A打电话给B
  第一次握手 : 你好, 我是A, 你能听到我说话吗? 第二次握手 : 听到了, 我是B, 你能听到我说话吗? 第三次握手 : 听到了, 我们可以开始聊天了。 三次握手其实就是为了检测双方的发送和接收能力是否正常。

-----

* #### 为什么要等待2MSL(Maximum Segment Lifetime)时间, 才从TIME_WAIT到CLOSED？
  答：这有两个理由：
（1）保证A发送的最后一个ACK报文能够到达B。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN+ACK片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。如果Client不等待一段时间，则有可能会对Server发来的FIN+ACK报文回以RST导致Server无法进入CLOSED状态。
（2）防止旧连接请求报文影响新的连接。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。Client在发送完ACK后，再经过2MSL，就可以使本连接持续时间内所产生的所有报文段从网络中消失。
更加接地气的解释 :
第一次挥手 : A告诉B, 我没数据发了, 准备关闭连接了, 你要发送数据吗第二次挥手 : B发送最后的数据第三次挥手 : B告诉A, 我也要关闭连接了第四次挥手 : A告诉B你可以关闭了, 我这边也关闭了

-----

* #### TCP定时器
    答：  （1）重传计时器：
  重传定时器：为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，就创建这个特定报文段的重传计时器，可能发生两种情况：若在计时器超时之前收到对报文段的确认，则撤销计时器；若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位；
  重传时间=2RTT；
  RTT的值应该动态计算。常用的公式是：`RTT=previous RTTi + （1-i）*current RTT`。i的值通常取90%，即新的RTT是以前的RTT值的90%加上当前RTT值的10%.
  Karn算法：对重传报文，在计算新的RTT时，不考虑重传报文的RTT。因为无法推理出：发送端所收到的确认是对上一次报文段的确认还是对重传报文段的确认。干脆不计入。
  （2）坚持计时器：persistent timer
  专门为对付零窗口通知而设立的。
  当发送端收到零窗口的确认时，就启动坚持计时器，当坚持计时器截止期到时，发送端TCP就发送一个特殊的报文段，叫探测报文段，这个报文段只有一个字节的数据。探测报文段有序号，但序号永远不需要确认，甚至在计算对其他部分数据的确认时这个序号也被忽略。探测报文段提醒接收端TCP，确认已丢失，必须重传。
  坚持计时器的截止期设置为重传时间的值，但若没有收到从接收端来的响应，则发送另一个探测报文段，并将坚持计时器的值加倍和并复位，发送端继续发送探测报文段，将坚持计时器的值加倍和复位，知道这个值增大到阈值为止（通常为60秒）。之后，发送端每隔60s就发送一个报文段，直到窗口重新打开为止；
  （3）保活计时器：keeplive timer
  每当服务器收到客户的信息，就将keeplive timer复位，超时通常设置2小时，若服务器超过2小时还没有收到来自客户的信息，就发送探测报文段，若发送了10个探测报文段（没75秒发送一个）还没收到响应，则终止连接。
  （4）时间等待计时器：Time_Wait Timer
  在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。
